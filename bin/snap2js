#!/usr/bin/env node

const prog = require('caporal');
const version = require('../package.json');
const snap2js = require('..');
const Q = require('q');
const path = require('path');
const fs = require('fs');
const exists = require('exists-file');
const browserify = require('browserify');
const BROWSERIFY_OPTS = {
    noParse: [ undefined ],
    extensions: [],
    ignoreTransform: [],
    fullPaths: false,
    builtins: false,
    commondir: false,
    bundleExternal: true,
    basedir: undefined,
    browserField: false,
    transformKey: undefined,
    dedupe: true,
    detectGlobals: true,
    insertGlobals: false,
    insertGlobalVars:
    {
        process: undefined,
        global: undefined,
        'Buffer.isBuffer': undefined,
        Buffer: undefined
    },
    ignoreMissing: false,
    debug: false,
    standalone: undefined
};

prog
    .version(version)
    .description('A tool to compile Snap! xml files to JavaScript')
    .argument('<files...>', 'Snap xml files to compile')
    .option('-i,--interpret')
    .option('--output <dir>', 'Output directory', fileExists, '.')
    .option('--context <type>', 'Context to use', isContext, 'basic')
    .action((args, opts, logger) => {
        if (opts.interpret) {
            if (args.files.length > 1) logger.warn(`Only interpretting ${args.files[0]}`)
            return interpretFile(args.files[0], opts, logger);
        } else {
            return Q.all(args.files.map(filename => saveToFile(filename, opts, logger)));
        }
    });

function compileFile(filename, opts, logger) {
    return Q.ninvoke(fs, 'readFile', filename)
        .then(contents => snap2js.transpile(contents))
        .fail(err => console.error(err));
}

function saveToFile(filename, opts, logger) {
    let outfile = path.join(opts.output, path.basename(filename).replace(/\.[a-zA-Z0-9]+$/, '.js'));
    let tmpfile = outfile + '.tmp';
    let context = opts.context;

    logger.debug('compiling ' + filename + ' to ' + outfile);
    return compileFile(filename, opts, logger)
        .then(fn => {
            var relPath = path.resolve(`${path.dirname(__dirname)}/src/context/${context}`);
            var contextPath = path.relative(path.resolve(opts.output), relPath);
            var code = `(${fn.toString()})(require('./${contextPath}'))`;
            return Q.ninvoke(fs, 'writeFile', tmpfile, code);
        })
        .then(() => {
            var b = browserify([tmpfile], BROWSERIFY_OPTS),
                outputStream = fs.createWriteStream(outfile);

            b.bundle().pipe(outputStream);
            outputStream.on('error',
                err => logger.warn(err));

            outputStream.on('close', () => {
                logger.debug('finished compiling ' + outfile);
                logger.debug('removing ' + tmpfile);
                fs.unlinkSync(tmpfile);
            });
        })
        .fail(err => console.error(err));
}

function interpretFile(filename, opts, logger) {
    let context = opts.context;
    return Q.ninvoke(fs, 'readFile', filename)
        .then(contents => snap2js.compile(contents))
        .then(fn => {
            const env = require(`../src/context/${context}`);

            return fn(env);
        })
        .catch(err => console.error('error', err));
}

function fileExists(dir) {
    dir = path.resolve(dir);
    if (!exists.sync(dir)) {
        throw new Error(`Output directory not found: ${dir}`);
    }
    return dir;
}

function isContext(name) {
    var contexts = fs.readdirSync(path.join(__dirname, '..', 'src', 'context'))
        .map(name => name.replace(/\.js$/, ''));

    var isValid = contexts.find(filename => filename === name.toLowerCase());

    if (!isValid) {
        throw new Error(`Invalid context: ${dir}. Expected ${contexts.join(', ')}`);
    }
    return name.toLowerCase();
}

prog.parse(process.argv);
